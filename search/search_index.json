{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Brev Brev is a developer environment handling the infrastructure so you can focus on your code. The documentation is broken into 4 sections Sections Tutorials Learning oriented , end-to-end guides on how to build something with Brev. Starting out? This is a good one . How-To Problem oriented guides to help you figure out something you might be working through. Reference Information oriented guides to shed light on the underlying systems. Discussions Understanding oriented guides to shed light on our how and why.","title":"Welcome to Brev"},{"location":"#welcome-to-brev","text":"Brev is a developer environment handling the infrastructure so you can focus on your code. The documentation is broken into 4 sections Sections Tutorials Learning oriented , end-to-end guides on how to build something with Brev. Starting out? This is a good one . How-To Problem oriented guides to help you figure out something you might be working through. Reference Information oriented guides to shed light on the underlying systems. Discussions Understanding oriented guides to shed light on our how and why.","title":"Welcome to Brev"},{"location":"discussions/","text":"Discussions Best Practices for Brev Storage There are a lot of options around which database to use and how. Brev DB is a simple key value store, but powered with Pydantic's BaseModel classes, lends itself to some really clean use cases. Our Two Principles Why we created Brev.","title":"Home"},{"location":"discussions/#discussions","text":"","title":"Discussions"},{"location":"discussions/#best-practices-for-brev-storage","text":"There are a lot of options around which database to use and how. Brev DB is a simple key value store, but powered with Pydantic's BaseModel classes, lends itself to some really clean use cases.","title":"Best Practices for Brev Storage"},{"location":"discussions/#our-two-principles","text":"Why we created Brev.","title":"Our Two Principles"},{"location":"discussions/best-practices-for-brev-database/","text":"Discussion #1 Best Practices for Brev Storage The Brev DB is a simple key value store. It's a nosql database, but even if you're using sql, much of this discussions is still very relevant. Let's build a simple API to get and create users. Create an endpoint and make sure you have a GET call for fetching the users, and a POST call for creating the users. import variables import shared def get (): return {} def post (): return {} Add the database. We'll just name this table \"Users\". Don't forget to pass the db in to both of your functions. import variables import shared from global_storage import storage_context def get ( db = storage_context ( \"Users\" )): return {} def post ( db = storage_context ( \"Users\" )): return {} We want to create the user via a POST call and an incoming JSON object. We can create a pydantic class to represent the expected incoming data, and simply pass it in to our post call. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): return { f \"Welcome { user . name } \" } Below is a naive implementation of using the db to add users. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } There are a couple flaws with this method: We might want different fields for different transactions. For example, create_date should be generated on the server, not on the incoming json. The creation logic should be separated, otherwise you might find yourself replicating the logic in multiple places. We should isolate database operations from the in-memory object. This will allow your code to require less refactoring if you change the underlying database. To start, let's add a function to create the user. In our case this is trivial, but it could include some more complicated logic later, like triggering some downstream effect. This function should be part of the pydantic class. Since we want this function to create an instance of the class, not operate on an instance, we will use a class method. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } Two things to notice: 1. The create_date is now generated by the create function, not from incoming json. 2. The instance is created, but nothing is persisted in the database. There are use cases where not persisting in the database is desirable. Say you have a logic flow of first creating the user, then verifying if they have a specific attribute, which without one, you want to abort. Rather than always persisting the user then having to clean up if it was a mistake, now you have to be intentional about persisting the user. Let's go ahead and add the persisting function. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } Few things to notice. Unlike the create function, we need an instance of the user to persist in the database, so the add function is not a classmethod. It will only operate on a user. It requires you to pass in the instance of the database you want to add. .dict() is a built in pydantic function that converts the user object to a dictionary before persisting. Notice how we are no longer using the create_date being passed in, and generating it on creation instead. We should modify our post call so it doesn't require the extraneous field. We changed the name of the original BaseModel class, so we actually don't have to modify the class we pass in to the POST call. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () class PostUserSchema ( BaseModel ): phone : str name : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } Now let's use our create and add function! import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () class PostUserSchema ( BaseModel ): phone : str name : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): user = User . create ( ** postUser . dict ()) user . add ( db ) return { f \"Welcome { user . name } \" } Yay! It works! Now we just need a function to get the users for our GET request. This function will also be a classmethod, since you should be able to get all the users without needing an instance of user. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) @classmethod def getAll ( cls , db ): return db . items () def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () class PostUserSchema ( BaseModel ): phone : str name : str def get ( db = storage_context ( \"Users\" )): return User . getAll ( db ) def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): user = User . create ( ** postUser . dict ()) user . add ( db ) return { f \"Welcome { user . name } \" } And that's it! We'd love to continue this discussion. Reach us on slack or text Nader at 415-818-0207","title":"Brev DB Best Practices"},{"location":"discussions/best-practices-for-brev-database/#discussion-1","text":"","title":"Discussion #1"},{"location":"discussions/best-practices-for-brev-database/#best-practices-for-brev-storage","text":"The Brev DB is a simple key value store. It's a nosql database, but even if you're using sql, much of this discussions is still very relevant. Let's build a simple API to get and create users. Create an endpoint and make sure you have a GET call for fetching the users, and a POST call for creating the users. import variables import shared def get (): return {} def post (): return {} Add the database. We'll just name this table \"Users\". Don't forget to pass the db in to both of your functions. import variables import shared from global_storage import storage_context def get ( db = storage_context ( \"Users\" )): return {} def post ( db = storage_context ( \"Users\" )): return {} We want to create the user via a POST call and an incoming JSON object. We can create a pydantic class to represent the expected incoming data, and simply pass it in to our post call. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): return { f \"Welcome { user . name } \" } Below is a naive implementation of using the db to add users. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } There are a couple flaws with this method: We might want different fields for different transactions. For example, create_date should be generated on the server, not on the incoming json. The creation logic should be separated, otherwise you might find yourself replicating the logic in multiple places. We should isolate database operations from the in-memory object. This will allow your code to require less refactoring if you change the underlying database. To start, let's add a function to create the user. In our case this is trivial, but it could include some more complicated logic later, like triggering some downstream effect. This function should be part of the pydantic class. Since we want this function to create an instance of the class, not operate on an instance, we will use a class method. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } Two things to notice: 1. The create_date is now generated by the create function, not from incoming json. 2. The instance is created, but nothing is persisted in the database. There are use cases where not persisting in the database is desirable. Say you have a logic flow of first creating the user, then verifying if they have a specific attribute, which without one, you want to abort. Rather than always persisting the user then having to clean up if it was a mistake, now you have to be intentional about persisting the user. Let's go ahead and add the persisting function. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } Few things to notice. Unlike the create function, we need an instance of the user to persist in the database, so the add function is not a classmethod. It will only operate on a user. It requires you to pass in the instance of the database you want to add. .dict() is a built in pydantic function that converts the user object to a dictionary before persisting. Notice how we are no longer using the create_date being passed in, and generating it on creation instead. We should modify our post call so it doesn't require the extraneous field. We changed the name of the original BaseModel class, so we actually don't have to modify the class we pass in to the POST call. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () class PostUserSchema ( BaseModel ): phone : str name : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): db [ \"id\" ] = postUser . dict () return { f \"Welcome { user . name } \" } Now let's use our create and add function! import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () class PostUserSchema ( BaseModel ): phone : str name : str def get ( db = storage_context ( \"Users\" )): return {} def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): user = User . create ( ** postUser . dict ()) user . add ( db ) return { f \"Welcome { user . name } \" } Yay! It works! Now we just need a function to get the users for our GET request. This function will also be a classmethod, since you should be able to get all the users without needing an instance of user. import variables import shared from global_storage import storage_context from pydantic import BaseModel class User ( BaseModel ): phone : str name : str create_date : str @classmethod def create ( cls , name , phone ): return cls ( name = name , phone = phone , create_date = datetime . datetime . now () . isoformat ()) @classmethod def getAll ( cls , db ): return db . items () def add ( self , db ): db [ self . phone ] = self . dict () return self . dict () class PostUserSchema ( BaseModel ): phone : str name : str def get ( db = storage_context ( \"Users\" )): return User . getAll ( db ) def post ( postUser : PostUserSchema , db = storage_context ( \"Users\" )): user = User . create ( ** postUser . dict ()) user . add ( db ) return { f \"Welcome { user . name } \" } And that's it! We'd love to continue this discussion. Reach us on slack or text Nader at 415-818-0207","title":"Best Practices for Brev Storage"},{"location":"discussions/our-two-principles/","text":"Discussion #2 Our Two Principles 1. Abstraction is powerful Abstraction is incredibly powerful, so we're seeing a lot of companies leveraging this. By abstracting away unecessary variables, you're able to move faster with all of your focus. Abstraction is at the core of computing, and we should always be asking ourselves what can be abstracted. How can we stand on the shoulders of the last decade and see further? 2. Abstraction is compromise This point is often overlooked. Abstractions work for specific use cases, but the key to leveraging abstraction is the ability to navigate the ladder. There are times when you have to go down the ladder of abstraction, which frameworks and platforms often do not allow. We need to be intellectually honest with ourselves, acknowledging that our abstraction won't work for every use case. If you can abstract away details, you absolutely should. However, you should easily be able to peel back the abstraction as you need. What you're building should be only as difficult as the domain it's in. We feel very strongly about this. If you're building a rocket, it should be as hard as rocket science. If you're building a dating app, your success should not be driven by deep infrastructure expertise, but rather by the domain expertise that lies in the business logic: how do users match, how do they talk to each other, etc. Note This is an early product. We're still figuring out the abstraction layer, so a lot of the traversals aren't fully built out yet. We don't build anything without discussing how going under the hood would work, and will eventually support full customization. For now, if there's a limit, do reach out and we'll help with your specific use case, even if that means handing your entire server instance over to you.","title":"Our 2 Principles"},{"location":"discussions/our-two-principles/#discussion-2","text":"","title":"Discussion #2"},{"location":"discussions/our-two-principles/#our-two-principles","text":"","title":"Our Two Principles"},{"location":"discussions/our-two-principles/#1-abstraction-is-powerful","text":"Abstraction is incredibly powerful, so we're seeing a lot of companies leveraging this. By abstracting away unecessary variables, you're able to move faster with all of your focus. Abstraction is at the core of computing, and we should always be asking ourselves what can be abstracted. How can we stand on the shoulders of the last decade and see further?","title":"1. Abstraction is powerful"},{"location":"discussions/our-two-principles/#2-abstraction-is-compromise","text":"This point is often overlooked. Abstractions work for specific use cases, but the key to leveraging abstraction is the ability to navigate the ladder. There are times when you have to go down the ladder of abstraction, which frameworks and platforms often do not allow. We need to be intellectually honest with ourselves, acknowledging that our abstraction won't work for every use case. If you can abstract away details, you absolutely should. However, you should easily be able to peel back the abstraction as you need.","title":"2. Abstraction is compromise"},{"location":"discussions/our-two-principles/#what-youre-building-should-be-only-as-difficult-as-the-domain-its-in","text":"We feel very strongly about this. If you're building a rocket, it should be as hard as rocket science. If you're building a dating app, your success should not be driven by deep infrastructure expertise, but rather by the domain expertise that lies in the business logic: how do users match, how do they talk to each other, etc. Note This is an early product. We're still figuring out the abstraction layer, so a lot of the traversals aren't fully built out yet. We don't build anything without discussing how going under the hood would work, and will eventually support full customization. For now, if there's a limit, do reach out and we'll help with your specific use case, even if that means handing your entire server instance over to you.","title":"What you're building should be only as difficult as the domain it's in."},{"location":"howto/","text":"How To How To Add Query Params To Your Endpoint Add query parameters to any endpoint How To Add JSON body To Your Endpoint Use JSON body with any endpoint How To Access Stdout Find the stdout/print statements outside of the Brev runner. How To Add Environment Variables Add encrypted environment variables rather than committing secrets in your code. How to Create an Endpoint Create an endpoint in your Brev project How To Accept Different HTTP Methods Use different HTTP methods on your endpoints How to Store Data Set up and use a database in seconds. How to Save a File Save files on Brev and access a permanent link to them. How To Pass Request Files to Your Endpoints You can use a file as input to any of your endpoints. How To Return Custom Responses Return a custom response object using Starlette's response object.","title":"Home"},{"location":"howto/#how-to","text":"","title":"How To"},{"location":"howto/#how-to-add-query-params-to-your-endpoint","text":"Add query parameters to any endpoint","title":"How To Add Query Params To Your Endpoint"},{"location":"howto/#how-to-add-json-body-to-your-endpoint","text":"Use JSON body with any endpoint","title":"How To Add JSON body To Your Endpoint"},{"location":"howto/#how-to-access-stdout","text":"Find the stdout/print statements outside of the Brev runner.","title":"How To Access Stdout"},{"location":"howto/#how-to-add-environment-variables","text":"Add encrypted environment variables rather than committing secrets in your code.","title":"How To Add Environment Variables"},{"location":"howto/#how-to-create-an-endpoint","text":"Create an endpoint in your Brev project","title":"How to Create an Endpoint"},{"location":"howto/#how-to-accept-different-http-methods","text":"Use different HTTP methods on your endpoints","title":"How To Accept Different HTTP Methods"},{"location":"howto/#how-to-store-data","text":"Set up and use a database in seconds.","title":"How to Store Data"},{"location":"howto/#how-to-save-a-file","text":"Save files on Brev and access a permanent link to them.","title":"How to Save a File"},{"location":"howto/#how-to-pass-request-files-to-your-endpoints","text":"You can use a file as input to any of your endpoints.","title":"How To Pass Request Files to Your Endpoints"},{"location":"howto/#how-to-return-custom-responses","text":"Return a custom response object using Starlette's response object.","title":"How To Return Custom Responses"},{"location":"howto/add-environment-variables/","text":"How To #4 How To Add Environment Variables You can add environment variables to any Brev endpoint. It's a good practice to avoid using secret keys and other system level variables directly in the code. CLI From the CLI, use the add command on the env resource: brev env add MY_SECRET_KEY This will prompt you to enter the value, and that's it! Console Open the environment variables, add the variable name and value, click add variable ! Note: these variables are protected per project. The variable value is encrypted and we don't support changing it. However, you can always delete it and add it back again with a different value. Freely use the variable in your code, insuring variables is imported: import variables def get (): print ( f \"Secret Key: { MY_SECRET_KEY } \" ) return {} Doing this will make your code more secure, since the secret keys are encrypted and not pushed as part of your code. Additionally, your code will be cleaner since changing this variable only needs to happen in one place, no matter how often you use the variable.","title":"How To Add Environment Variables"},{"location":"howto/add-environment-variables/#how-to-4","text":"","title":"How To #4"},{"location":"howto/add-environment-variables/#how-to-add-environment-variables","text":"You can add environment variables to any Brev endpoint. It's a good practice to avoid using secret keys and other system level variables directly in the code. CLI From the CLI, use the add command on the env resource: brev env add MY_SECRET_KEY This will prompt you to enter the value, and that's it! Console Open the environment variables, add the variable name and value, click add variable ! Note: these variables are protected per project. The variable value is encrypted and we don't support changing it. However, you can always delete it and add it back again with a different value. Freely use the variable in your code, insuring variables is imported: import variables def get (): print ( f \"Secret Key: { MY_SECRET_KEY } \" ) return {} Doing this will make your code more secure, since the secret keys are encrypted and not pushed as part of your code. Additionally, your code will be cleaner since changing this variable only needs to happen in one place, no matter how often you use the variable.","title":"How To Add Environment Variables"},{"location":"howto/how-to-accept-different-http-methods/","text":"How To #6 How to accept different HTTP Methods To handle different http methods for a given url, create new functions named with the http request type you would like to handle. For example: def get () return { \"message\" : \"GET\" } def post () return { \"message\" : \"POST\" } def put () return { \"message\" : \"PUT\" } def delete () return { \"message\" : \"DELETE\" } Brev supports any of the following HTTP methods: get post put delete options head patch trace","title":"How To Accept Different HTTP Methods"},{"location":"howto/how-to-accept-different-http-methods/#how-to-6","text":"","title":"How To #6"},{"location":"howto/how-to-accept-different-http-methods/#how-to-accept-different-http-methods","text":"To handle different http methods for a given url, create new functions named with the http request type you would like to handle. For example: def get () return { \"message\" : \"GET\" } def post () return { \"message\" : \"POST\" } def put () return { \"message\" : \"PUT\" } def delete () return { \"message\" : \"DELETE\" } Brev supports any of the following HTTP methods: get post put delete options head patch trace","title":"How to accept different HTTP Methods"},{"location":"howto/how-to-add-json-body/","text":"How To #2 How To Add JSON Body Query parameters can be used for simple variables, but often you'll have more complex data to send to API, or you want it sent over more securely, rather than as part of the URL. We can do this by sending our data as a JSON object. The JSON object can hold anything, so we need to define the data before passing to a Brev function. Defining the data allows the automatic validation to take place, so your code only gets executed if the proper inputs were received. 1: Define the data with pydantic BaseModel class from pydantic import BaseModel class MyJsonBody ( Model ): best_tv_show_ever : str does_kel_love_orange_soda : True 2: Pass an instance of the class to the function from pydantic import BaseModel class MyJsonBody ( Model ): best_tv_show_ever : str does_kel_love_orange_soda : True def get ( incoming : MyJsonBody ): return { \"result\" : incoming . does_kel_love_orange_soda } That's it! You can now access the incoming JSON as an instance of your pydantic class!","title":"How To Add JSON Body"},{"location":"howto/how-to-add-json-body/#how-to-2","text":"","title":"How To #2"},{"location":"howto/how-to-add-json-body/#how-to-add-json-body","text":"Query parameters can be used for simple variables, but often you'll have more complex data to send to API, or you want it sent over more securely, rather than as part of the URL. We can do this by sending our data as a JSON object. The JSON object can hold anything, so we need to define the data before passing to a Brev function. Defining the data allows the automatic validation to take place, so your code only gets executed if the proper inputs were received.","title":"How To Add JSON Body"},{"location":"howto/how-to-add-json-body/#1-define-the-data-with-pydantic-basemodel-class","text":"from pydantic import BaseModel class MyJsonBody ( Model ): best_tv_show_ever : str does_kel_love_orange_soda : True","title":"1: Define the data with pydantic BaseModel class"},{"location":"howto/how-to-add-json-body/#2-pass-an-instance-of-the-class-to-the-function","text":"from pydantic import BaseModel class MyJsonBody ( Model ): best_tv_show_ever : str does_kel_love_orange_soda : True def get ( incoming : MyJsonBody ): return { \"result\" : incoming . does_kel_love_orange_soda } That's it! You can now access the incoming JSON as an instance of your pydantic class!","title":"2: Pass an instance of the class to the function"},{"location":"howto/how-to-add-query-params/","text":"How To #1 How To Add Query Params Query parameters are variables encoded in the URL of your API/endpoint. For example https://slug.brev.dev/api/test?greeting=hola In this case, greeting is the variable, and hola is the value of greeting . To use this in an endpoint on Brev, simply pass the variable name into your function. For example, for the above call, the following function def get ( greeting ) return { \"greeting\" : f \" { greeting } \" } would return { \"greeting\" : \"hola\" }","title":"How To Add Query Params"},{"location":"howto/how-to-add-query-params/#how-to-1","text":"","title":"How To #1"},{"location":"howto/how-to-add-query-params/#how-to-add-query-params","text":"Query parameters are variables encoded in the URL of your API/endpoint. For example https://slug.brev.dev/api/test?greeting=hola In this case, greeting is the variable, and hola is the value of greeting . To use this in an endpoint on Brev, simply pass the variable name into your function. For example, for the above call, the following function def get ( greeting ) return { \"greeting\" : f \" { greeting } \" } would return { \"greeting\" : \"hola\" }","title":"How To Add Query Params"},{"location":"howto/how-to-create-endpoint/","text":"How To #5 How to Create an Endpoint CLI To create an endpoint, simply use the add command on the endpoint resource. brev endpoint add MyNewEndpoint You'll now have a file MyNewEndpoint.py which has a get function. Console Click on the \"Add Endpoint\" button. Give it a name, and a new resource file will be created with a get function. You can handle other request types, see more on the next page.","title":"How To Create an Endpoint"},{"location":"howto/how-to-create-endpoint/#how-to-5","text":"","title":"How To #5"},{"location":"howto/how-to-create-endpoint/#how-to-create-an-endpoint","text":"CLI To create an endpoint, simply use the add command on the endpoint resource. brev endpoint add MyNewEndpoint You'll now have a file MyNewEndpoint.py which has a get function. Console Click on the \"Add Endpoint\" button. Give it a name, and a new resource file will be created with a get function. You can handle other request types, see more on the next page.","title":"How to Create an Endpoint"},{"location":"howto/how-to-pass-request-files-to-endpoints/","text":"How To #8 How to pass request files to your endpoints To receive files sent as form data you can declare an argument with default value of File(...) . from fastapi import File def post ( file_contents : bytes = File ( ... )): return {} We can use Brev's built in file uploader to save the file and return a link to it! from fastapi import File import file_storage def post ( file_contents : bytes = File ( ... )): link = file_storage . upload ( file_contents ) return { \"file_url\" : link }","title":"How To Pass Request Files"},{"location":"howto/how-to-pass-request-files-to-endpoints/#how-to-8","text":"","title":"How To #8"},{"location":"howto/how-to-pass-request-files-to-endpoints/#how-to-pass-request-files-to-your-endpoints","text":"To receive files sent as form data you can declare an argument with default value of File(...) . from fastapi import File def post ( file_contents : bytes = File ( ... )): return {} We can use Brev's built in file uploader to save the file and return a link to it! from fastapi import File import file_storage def post ( file_contents : bytes = File ( ... )): link = file_storage . upload ( file_contents ) return { \"file_url\" : link }","title":"How to pass request files to your endpoints"},{"location":"howto/how-to-store-data/","text":"How To #7 How to Store Data You probably want to persist data in a database. Brev's built in database is great for simple applications, or you can fully configure your own database if your use case demands it. Brev's db is a key-value, nosql database. We highly recommend you check out this discussion about how to best utilize it in your application. You can fully configure your own database, or use the built in Brev DB. Import global_storage: from global_storage import storage_context This is the database object. Pass in a reference to the table you want. Brev will automatically create and configure it for you. from global_storage import storage_context def get ( db = storage_context ( \"my_items\" )): ... This passes a reference to the table my_items , and creates the table first if needed. It interfaces a lot like a python dictionary. from global_storage import storage_context def get ( db = storage_context ( \"my_items\" )): db [ key ] = value # store an item ... You can read more about the storage_context here .","title":"How To Store Data"},{"location":"howto/how-to-store-data/#how-to-7","text":"","title":"How To #7"},{"location":"howto/how-to-store-data/#how-to-store-data","text":"You probably want to persist data in a database. Brev's built in database is great for simple applications, or you can fully configure your own database if your use case demands it. Brev's db is a key-value, nosql database. We highly recommend you check out this discussion about how to best utilize it in your application. You can fully configure your own database, or use the built in Brev DB. Import global_storage: from global_storage import storage_context This is the database object. Pass in a reference to the table you want. Brev will automatically create and configure it for you. from global_storage import storage_context def get ( db = storage_context ( \"my_items\" )): ... This passes a reference to the table my_items , and creates the table first if needed. It interfaces a lot like a python dictionary. from global_storage import storage_context def get ( db = storage_context ( \"my_items\" )): db [ key ] = value # store an item ... You can read more about the storage_context here .","title":"How to Store Data"},{"location":"howto/read-print-statements-outside-of-brev-cli-console/","text":"How To #3 Read Print Statements Outside of Brev CLI or Console Executing any of your endpoints using the enpoint runner in the console or through the CLI ( run command) will display your print statements. If you want to view the stdout in a different environment, for example, in a react front end app, we've made it available in the header. Look for the x-stdout header in the networks tab or print it out. Note: it will be URL encoded. x-stdout: %5Bprint%5D%20%5Bendpoint.websiteForm.get%3A8%5D%20hey%20from%20brev%0A","title":"How To Process Stdout"},{"location":"howto/read-print-statements-outside-of-brev-cli-console/#how-to-3","text":"","title":"How To #3"},{"location":"howto/read-print-statements-outside-of-brev-cli-console/#read-print-statements-outside-of-brev-cli-or-console","text":"Executing any of your endpoints using the enpoint runner in the console or through the CLI ( run command) will display your print statements. If you want to view the stdout in a different environment, for example, in a react front end app, we've made it available in the header. Look for the x-stdout header in the networks tab or print it out. Note: it will be URL encoded. x-stdout: %5Bprint%5D%20%5Bendpoint.websiteForm.get%3A8%5D%20hey%20from%20brev%0A","title":"Read Print Statements Outside of Brev CLI or Console"},{"location":"howto/return-a-custom-response/","text":"How To #9 How to return a custom response Http responses are used to send data back to the client. Responses include a body, headers, cookies, and a status code. As you have seen, you can create a response by returning from an endpoint handler. By default the response status code is 200. The object returned will be used as the body. def post (): return { \"return\" : True } # returns 200 To return a custom response you can return a Starlette response object . Simply import JSONResponse and return that instead. from fastapi.responses import JSONResponse def post (): return JSONResponse ( status_code = 201 , content = { \"message\" : \"created\" })","title":"How To Return Custom Responses"},{"location":"howto/return-a-custom-response/#how-to-9","text":"","title":"How To #9"},{"location":"howto/return-a-custom-response/#how-to-return-a-custom-response","text":"Http responses are used to send data back to the client. Responses include a body, headers, cookies, and a status code. As you have seen, you can create a response by returning from an endpoint handler. By default the response status code is 200. The object returned will be used as the body. def post (): return { \"return\" : True } # returns 200 To return a custom response you can return a Starlette response object . Simply import JSONResponse and return that instead. from fastapi.responses import JSONResponse def post (): return JSONResponse ( status_code = 201 , content = { \"message\" : \"created\" })","title":"How to return a custom response"},{"location":"howto/save-a-file/","text":"How To # 10 How to Save a File You can save a file using Brev's built in file uploader . from fastapi import File import file_storage def post () # file_contents = ... link = file_storage . upload ( file_contents ) return { \"file_url\" : link } The file uploader .upload() function returns a URL to your file. You can store that URL in your Brev DB or simply return it from your endpoint! The URL does not expire. See how to upload files to your endpoints here .","title":"How To Save a File"},{"location":"howto/save-a-file/#how-to-10","text":"","title":"How To # 10"},{"location":"howto/save-a-file/#how-to-save-a-file","text":"You can save a file using Brev's built in file uploader . from fastapi import File import file_storage def post () # file_contents = ... link = file_storage . upload ( file_contents ) return { \"file_url\" : link } The file uploader .upload() function returns a URL to your file. You can store that URL in your Brev DB or simply return it from your endpoint! The URL does not expire. See how to upload files to your endpoints here .","title":"How to Save a File"},{"location":"reference/","text":"Reference Brev is built on top of FastApi/ (v0.61.0) Starlette and supports much of its API. To dig deeper in request/response, validation and documenation it might be helpful to checkout their docs. Brev lets you create projects. In each project, you'll find: Endpoints: Code that responds to http requests. Shared Code: Code that can be shared by any endpoint in a project Packages: Installable 3rd party packages from PyPi that can be used in endpoints or shared code Variables: A secure way to use and manage secrets, keys, passwords and is also a good way to manage environment variables or global constants in your code. Storage: A simple key value database. It can be thought of as a persistent dictionary accross requests as its api closely mirrors python's native dict type. It's a great way to build a proof of concept without needing to hook up a database. Below are full references for Brev components. Brev DB (storage_context) The built-in Brev DB, imported as storage_context Shared Code Write code accessible by all of your endpoints. Environment Variables Use Brev's built-in encrypted secrets/environment variable manager rather than putting your secrets in plain text. Out-of-the-Box Functionality Send SMS text messages, save upload files, and run computer vision inference without any additional setup! Runtime and Environment Learn more about your Brev server's runtime and environment. Limitations Understand what limitations exist within a Brev deploy and applicable workarounds.","title":"Home"},{"location":"reference/#reference","text":"Brev is built on top of FastApi/ (v0.61.0) Starlette and supports much of its API. To dig deeper in request/response, validation and documenation it might be helpful to checkout their docs. Brev lets you create projects. In each project, you'll find: Endpoints: Code that responds to http requests. Shared Code: Code that can be shared by any endpoint in a project Packages: Installable 3rd party packages from PyPi that can be used in endpoints or shared code Variables: A secure way to use and manage secrets, keys, passwords and is also a good way to manage environment variables or global constants in your code. Storage: A simple key value database. It can be thought of as a persistent dictionary accross requests as its api closely mirrors python's native dict type. It's a great way to build a proof of concept without needing to hook up a database.","title":"Reference"},{"location":"reference/#below-are-full-references-for-brev-components","text":"","title":"Below are full references for Brev components."},{"location":"reference/#brev-db-storage_context","text":"The built-in Brev DB, imported as storage_context","title":"Brev DB (storage_context)"},{"location":"reference/#shared-code","text":"Write code accessible by all of your endpoints.","title":"Shared Code"},{"location":"reference/#environment-variables","text":"Use Brev's built-in encrypted secrets/environment variable manager rather than putting your secrets in plain text.","title":"Environment Variables"},{"location":"reference/#out-of-the-box-functionality","text":"Send SMS text messages, save upload files, and run computer vision inference without any additional setup!","title":"Out-of-the-Box Functionality"},{"location":"reference/#runtime-and-environment","text":"Learn more about your Brev server's runtime and environment.","title":"Runtime and Environment"},{"location":"reference/#limitations","text":"Understand what limitations exist within a Brev deploy and applicable workarounds.","title":"Limitations"},{"location":"reference/built-in-database-storage-context/","text":"Storage Context: The Brev Built-In Database Brev's built-in database is a minimal nosql key value store built on top of DynamoDB. Persist data between your API calls within a project without any configuration! Brev reliably handles throughput of 5000 requests/second Technical Details: The database supports eventual consistency Currently each collection is implemented as a single Dynamodb partition key. This works for most use cases but can be a bottle neck for high throughput applications. Python Usage The Brev DB works very similarly to python's dictionary type Access the database by importing storage_context from global_storage and using storage_context as the default value for a keyword argument in an endpoint. from global_storage import storage_context def get ( db = storage_context ( \"my_table_name\" )): val = db [ \"key\" ] # get item val = db . get ( \"key\" , \"default\" ) # get item and return 'default' if 'key' does not exist db [ \"key\" ] = \"value\" # set 'value' to 'key' val = db . setdefault ( \"key\" , \"value\" ) # set 'value' if 'key' does not exist return stored value return { \"value\" : val } Hint: as you access objects in the Brev DB, they are cached per request. Once the endpoint is ready to respond, the changes are saved to the database. Technical Detail: The storage_context is implemented as a dependency/dependable. Read more about FastAPI's lightweight depedency injection here . Collections You can think of Collections as your database table or database name. Declare different collections to group objects together by specificying the name of the collection as the parameter of storage_context . from global_storage import storage_context def get ( user_db = storage_context ( \"users\" ), item_db = storage_context ( \"items\" )): user_id = \"user_id\" email = user_db [ user_id ][ \"email\" ] items = item_db [ user_id ] return { \"email\" : email , \"items\" : items } View Your Database Contents You can use the database viewer in the Brev console to view or modify your database contents. Navigate to the Storage page, or use the cmd/ctrl + s keyboard shortcut. There's a script editor for ad hoc database scripts. You can use this for queries or modifications. Brev DB API Reference Types The following types can be used as keys to the Brev DB. StorageKey = Union [ int , str , bool , float ] The following is supported as values returned from the Brev DB. StorageValue = Union [ StorageKey , None , List , Dict ] Dependable storage . storage_context ( collection : str = \"default\" ) -> fastapi . Depends Parameters collection: a string to designate what collection of objects the storage context will be Returns: A fastapi dependable that creates a StorageContext yields the StorageContext then saves all changes made. StorageContext API class StorageContext : The StorageContext api is similar to a python dict object. Objects are ordered by insertion. __getitem___ __getitem__ ( key : StorageKey ) -> StorageValue Implements storage_context[key] bracket notation. Raises a KeyError if item does not exist. Parameters key: A StorageKey key to retrieve an object Returns: The object in storage if it exists in cache else retrieves from database __setitem___ __setitem__ ( self , key : StorageKey , value : StorageValue ) -> None : Parameters key: A StorageKey to be used for retrieval. value: A StorageValue which is used as its value. Returns: The object in storage if it exists in cache else retrieves from database __commit___ commit () -> None Manually save session cache to database. This is automatically called after you return from a endpoint handler. __get___ get ( key : StorageKey , default : Optional [ StorageValue ] = None ) -> StorageValue Parameters key: A StorageKey key to retrieve an object default: the value to return if the object does not exist Returns: The object in storage if it exists in cache else retrieves from database __update___ update ( to_update : Dict [ StorageKey , StorageValue ]) -> None Parameters to_update: a dict to bulk update keys and values in the database Returns: None setdefault setdefault ( key : StorageKey , default_value : StorageValue ) -> StorageValue Sets default_value as the value of key if key does not exist. Returns the value in the database, Parameters key: A StorageKey key to retrieve an object default: A StorageValue to be set if key does not exist Returns: A StorageValue object that is the value uses in a storage_context delitem ___delitem___ ( key : StorageKey ) -> None Implements del storage_context[key] syntax. Removes object with key from Storage. Parameters key: A StorageKey key to retrieve an object Returns: None pop pop ( key : StorageKey ) -> StorageValue Removes object with key from Storage and returns removed object Parameters key: A StorageKey key to retrieve an object Returns: StorageValue object in db clear clear () -> None Removes all items from database in collection len __len__ () -> int Implements len(storage_context) syntax. Returns number of items in the collection. Returns: An int of how many items are in the collection. contains __contains__ ( key : StorageKey ) -> bool Implements key in storage_context syntax. Returns bool if key exists in collection Parameters key: A StorageKey key to retrieve an object Returns: A bool. True if key exists. keys keys () -> Iterable [ StorageKey ] Retrieves all keys in a collection Returns: An iterable of keys values values () -> Iterable [ StorageValue ] Retrieves all values in a collection Returns: An iterable of StorageValue items items () -> Iterable [ Tuple ( StorageKey , StorageValue )] Retrieves all objects as an iterable tuple of StorageKey, StorageValue in a collection Returns: An iterable of Tuple(StorageKey, StorageValue)","title":"Brev DB (storage_context)"},{"location":"reference/built-in-database-storage-context/#storage-context-the-brev-built-in-database","text":"Brev's built-in database is a minimal nosql key value store built on top of DynamoDB. Persist data between your API calls within a project without any configuration! Brev reliably handles throughput of 5000 requests/second","title":"Storage Context: The Brev Built-In Database"},{"location":"reference/built-in-database-storage-context/#technical-details","text":"The database supports eventual consistency Currently each collection is implemented as a single Dynamodb partition key. This works for most use cases but can be a bottle neck for high throughput applications.","title":"Technical Details:"},{"location":"reference/built-in-database-storage-context/#python-usage","text":"The Brev DB works very similarly to python's dictionary type Access the database by importing storage_context from global_storage and using storage_context as the default value for a keyword argument in an endpoint. from global_storage import storage_context def get ( db = storage_context ( \"my_table_name\" )): val = db [ \"key\" ] # get item val = db . get ( \"key\" , \"default\" ) # get item and return 'default' if 'key' does not exist db [ \"key\" ] = \"value\" # set 'value' to 'key' val = db . setdefault ( \"key\" , \"value\" ) # set 'value' if 'key' does not exist return stored value return { \"value\" : val } Hint: as you access objects in the Brev DB, they are cached per request. Once the endpoint is ready to respond, the changes are saved to the database. Technical Detail: The storage_context is implemented as a dependency/dependable. Read more about FastAPI's lightweight depedency injection here .","title":"Python Usage"},{"location":"reference/built-in-database-storage-context/#collections","text":"You can think of Collections as your database table or database name. Declare different collections to group objects together by specificying the name of the collection as the parameter of storage_context . from global_storage import storage_context def get ( user_db = storage_context ( \"users\" ), item_db = storage_context ( \"items\" )): user_id = \"user_id\" email = user_db [ user_id ][ \"email\" ] items = item_db [ user_id ] return { \"email\" : email , \"items\" : items }","title":"Collections"},{"location":"reference/built-in-database-storage-context/#view-your-database-contents","text":"You can use the database viewer in the Brev console to view or modify your database contents. Navigate to the Storage page, or use the cmd/ctrl + s keyboard shortcut. There's a script editor for ad hoc database scripts. You can use this for queries or modifications.","title":"View Your Database Contents"},{"location":"reference/built-in-database-storage-context/#brev-db-api-reference","text":"","title":"Brev DB API Reference"},{"location":"reference/built-in-database-storage-context/#types","text":"The following types can be used as keys to the Brev DB. StorageKey = Union [ int , str , bool , float ] The following is supported as values returned from the Brev DB. StorageValue = Union [ StorageKey , None , List , Dict ]","title":"Types"},{"location":"reference/built-in-database-storage-context/#dependable","text":"storage . storage_context ( collection : str = \"default\" ) -> fastapi . Depends Parameters collection: a string to designate what collection of objects the storage context will be Returns: A fastapi dependable that creates a StorageContext yields the StorageContext then saves all changes made.","title":"Dependable"},{"location":"reference/built-in-database-storage-context/#storagecontext-api","text":"class StorageContext : The StorageContext api is similar to a python dict object. Objects are ordered by insertion.","title":"StorageContext API"},{"location":"reference/built-in-database-storage-context/#__getitem___","text":"__getitem__ ( key : StorageKey ) -> StorageValue Implements storage_context[key] bracket notation. Raises a KeyError if item does not exist. Parameters key: A StorageKey key to retrieve an object Returns: The object in storage if it exists in cache else retrieves from database","title":"__getitem___"},{"location":"reference/built-in-database-storage-context/#__setitem___","text":"__setitem__ ( self , key : StorageKey , value : StorageValue ) -> None : Parameters key: A StorageKey to be used for retrieval. value: A StorageValue which is used as its value. Returns: The object in storage if it exists in cache else retrieves from database","title":"__setitem___"},{"location":"reference/built-in-database-storage-context/#__commit___","text":"commit () -> None Manually save session cache to database. This is automatically called after you return from a endpoint handler.","title":"__commit___"},{"location":"reference/built-in-database-storage-context/#__get___","text":"get ( key : StorageKey , default : Optional [ StorageValue ] = None ) -> StorageValue Parameters key: A StorageKey key to retrieve an object default: the value to return if the object does not exist Returns: The object in storage if it exists in cache else retrieves from database","title":"__get___"},{"location":"reference/built-in-database-storage-context/#__update___","text":"update ( to_update : Dict [ StorageKey , StorageValue ]) -> None Parameters to_update: a dict to bulk update keys and values in the database Returns: None","title":"__update___"},{"location":"reference/built-in-database-storage-context/#setdefault","text":"setdefault ( key : StorageKey , default_value : StorageValue ) -> StorageValue Sets default_value as the value of key if key does not exist. Returns the value in the database, Parameters key: A StorageKey key to retrieve an object default: A StorageValue to be set if key does not exist Returns: A StorageValue object that is the value uses in a storage_context","title":"setdefault"},{"location":"reference/built-in-database-storage-context/#delitem","text":"___delitem___ ( key : StorageKey ) -> None Implements del storage_context[key] syntax. Removes object with key from Storage. Parameters key: A StorageKey key to retrieve an object Returns: None","title":"delitem"},{"location":"reference/built-in-database-storage-context/#pop","text":"pop ( key : StorageKey ) -> StorageValue Removes object with key from Storage and returns removed object Parameters key: A StorageKey key to retrieve an object Returns: StorageValue object in db","title":"pop"},{"location":"reference/built-in-database-storage-context/#clear","text":"clear () -> None Removes all items from database in collection","title":"clear"},{"location":"reference/built-in-database-storage-context/#len","text":"__len__ () -> int Implements len(storage_context) syntax. Returns number of items in the collection. Returns: An int of how many items are in the collection.","title":"len"},{"location":"reference/built-in-database-storage-context/#contains","text":"__contains__ ( key : StorageKey ) -> bool Implements key in storage_context syntax. Returns bool if key exists in collection Parameters key: A StorageKey key to retrieve an object Returns: A bool. True if key exists.","title":"contains"},{"location":"reference/built-in-database-storage-context/#keys","text":"keys () -> Iterable [ StorageKey ] Retrieves all keys in a collection Returns: An iterable of keys","title":"keys"},{"location":"reference/built-in-database-storage-context/#values","text":"values () -> Iterable [ StorageValue ] Retrieves all values in a collection Returns: An iterable of StorageValue","title":"values"},{"location":"reference/built-in-database-storage-context/#items","text":"items () -> Iterable [ Tuple ( StorageKey , StorageValue )] Retrieves all objects as an iterable tuple of StorageKey, StorageValue in a collection Returns: An iterable of Tuple(StorageKey, StorageValue)","title":"items"},{"location":"reference/env-secrets-manager/","text":"Variables Brev comes with a built in encrypted secrets/environment manager. Add any environment variable or secret by: CLI From the CLI, use the add command on the env resource: brev env add MY_SECRET_KEY This will prompt you to enter the value, and that's it! Console Open the environment variables, add the variable name and value, click add variable ! Note: these variables are protected per project. The variable value is encrypted and we don't support changing it. However, you can always delete it and add it back again with a different value. You can use any of your variables by the variables object in your endpoint code. For example: import variables def get (): return { \"var\" : variables . THIS_IS_MY_KEY }","title":"Environment Variables"},{"location":"reference/env-secrets-manager/#variables","text":"Brev comes with a built in encrypted secrets/environment manager. Add any environment variable or secret by: CLI From the CLI, use the add command on the env resource: brev env add MY_SECRET_KEY This will prompt you to enter the value, and that's it! Console Open the environment variables, add the variable name and value, click add variable ! Note: these variables are protected per project. The variable value is encrypted and we don't support changing it. However, you can always delete it and add it back again with a different value. You can use any of your variables by the variables object in your endpoint code. For example: import variables def get (): return { \"var\" : variables . THIS_IS_MY_KEY }","title":"Variables"},{"location":"reference/limitations/","text":"Limitations Every tool has its strengths and weaknesses. Here's when we think you should not use Brev (we wont stop you if you try). Critical applications that need high degrees of resiliency, stability, and security. Servers that require response times < 50ms. Applications that need more than 3GB of memory. Applications that need more than 512MB of file memory. CPU or GPU bottlenecked applications. Applications that require long running tasks of more than 15 minutes. Applications that are already in production. Applications that requires throughput of more than 10,000 requests/second We look to support all these use cases in the near future.","title":"Limitations"},{"location":"reference/limitations/#limitations","text":"Every tool has its strengths and weaknesses. Here's when we think you should not use Brev (we wont stop you if you try). Critical applications that need high degrees of resiliency, stability, and security. Servers that require response times < 50ms. Applications that need more than 3GB of memory. Applications that need more than 512MB of file memory. CPU or GPU bottlenecked applications. Applications that require long running tasks of more than 15 minutes. Applications that are already in production. Applications that requires throughput of more than 10,000 requests/second We look to support all these use cases in the near future.","title":"Limitations"},{"location":"reference/out-of-the-box-sms-file-upload-roboflow/","text":"Out-of-the-Box Functionality Brev comes with built in tools to make it easier to focus on building, not configuring. SMS Use the built in SMS messenger to send text messages from any endpoints. This is a great way to develop your prototype and see how quickly you can build a real application with Brev, however, you might be better off setting up Twilio for heavy production use cases. The built-in SMS comes from a real 10-digit number (not a short code). An exception will be thrown if the message fails to send. Simply import sms from a file in a Brev project. The API is sms . send ( phone_number : str , message : str ) Here's a full example: import sms sms . send ( \"415555555\" , \"hello from Brev!\" ) File Upload Often you want to store files like images, videos, docs, or arbitrary binary data. Use import file_storage to upload data. A long unique link containing the file will be returned. Note: anyone with access to the link will have access to the file, and the link does not expire. file_storage . upload ( data : Union [ bytes , BinaryIO ], content_type : Optional [ str ] = None , content_disposition : Optional [ str ] = None , content_encoding : Optional [ str ] = None ) -> str Parameters data A file like object or bytes can be used. content_type An optional string to specify the file media type . Specifying the correct type allows browsers do download the file correctly. content_disposition An optional string to specify the content disposition . This tells browsers if it should treat the file as part of a webpage or as a downloadable attachement. content_encoding an optional string to specify the content encoding . Returns Returns a complete url with a long unique id. Anyone who has access to this link has access to the file. Roboflow If you have a Roboflow computer vision model, you can infer your model with import roboflow . roboflow . infer ( model_id : str , image_base64 : str , format : Union [ roboflow . Format , str ] = roboflow . Format . json , access_token : Optional [ str ] = None , ) -> requests . Response Parameters model_id A file like object or bytes can be used. image_base64 The image data in base64. format A roboflow.Format type or string \"json\", \"image\" access_token The optional roboflow access token. If not provided here, ROBOFLOW_ACCESS_TOKEN must be set as an environment variable. Returns The requests.Response from the https://infer.roboflow.ai/{model} endpoint. ( See request libarary ) The following enum roboflow . Format : Enum has values: json = \"json\" image = \"image\"","title":"Out-of-the-Box Functionality"},{"location":"reference/out-of-the-box-sms-file-upload-roboflow/#out-of-the-box-functionality","text":"Brev comes with built in tools to make it easier to focus on building, not configuring.","title":"Out-of-the-Box Functionality"},{"location":"reference/out-of-the-box-sms-file-upload-roboflow/#sms","text":"Use the built in SMS messenger to send text messages from any endpoints. This is a great way to develop your prototype and see how quickly you can build a real application with Brev, however, you might be better off setting up Twilio for heavy production use cases. The built-in SMS comes from a real 10-digit number (not a short code). An exception will be thrown if the message fails to send. Simply import sms from a file in a Brev project. The API is sms . send ( phone_number : str , message : str ) Here's a full example: import sms sms . send ( \"415555555\" , \"hello from Brev!\" )","title":"SMS"},{"location":"reference/out-of-the-box-sms-file-upload-roboflow/#file-upload","text":"Often you want to store files like images, videos, docs, or arbitrary binary data. Use import file_storage to upload data. A long unique link containing the file will be returned. Note: anyone with access to the link will have access to the file, and the link does not expire. file_storage . upload ( data : Union [ bytes , BinaryIO ], content_type : Optional [ str ] = None , content_disposition : Optional [ str ] = None , content_encoding : Optional [ str ] = None ) -> str Parameters data A file like object or bytes can be used. content_type An optional string to specify the file media type . Specifying the correct type allows browsers do download the file correctly. content_disposition An optional string to specify the content disposition . This tells browsers if it should treat the file as part of a webpage or as a downloadable attachement. content_encoding an optional string to specify the content encoding . Returns Returns a complete url with a long unique id. Anyone who has access to this link has access to the file.","title":"File Upload"},{"location":"reference/out-of-the-box-sms-file-upload-roboflow/#roboflow","text":"If you have a Roboflow computer vision model, you can infer your model with import roboflow . roboflow . infer ( model_id : str , image_base64 : str , format : Union [ roboflow . Format , str ] = roboflow . Format . json , access_token : Optional [ str ] = None , ) -> requests . Response Parameters model_id A file like object or bytes can be used. image_base64 The image data in base64. format A roboflow.Format type or string \"json\", \"image\" access_token The optional roboflow access token. If not provided here, ROBOFLOW_ACCESS_TOKEN must be set as an environment variable. Returns The requests.Response from the https://infer.roboflow.ai/{model} endpoint. ( See request libarary ) The following enum roboflow . Format : Enum has values: json = \"json\" image = \"image\"","title":"Roboflow"},{"location":"reference/runtime-and-environment/","text":"Runtime and Environment Brev containerizes and isolates each project. Python 3.7 is currently the only supported runtime. Each request has a timeout of 30 seconds. Each project can support up to 512MB of packages. The file system is read only except for /tmp . /tmp has a maximum storage of 512MB. Each project has by default 1GB of memory. You can request a maximum of 3GB of memory. The server has been load tested with one client and handled 800 req/sec with median response times of 110ms. Results may vary depending on application. More testing needs to be conducted. We believe the current upper bound is 5,000 req/sec. Technical Detail : Brev is currently built on top of AWS Lambda where each project is a separate Lambda.","title":"Runtime and Environment"},{"location":"reference/runtime-and-environment/#runtime-and-environment","text":"Brev containerizes and isolates each project. Python 3.7 is currently the only supported runtime. Each request has a timeout of 30 seconds. Each project can support up to 512MB of packages. The file system is read only except for /tmp . /tmp has a maximum storage of 512MB. Each project has by default 1GB of memory. You can request a maximum of 3GB of memory. The server has been load tested with one client and handled 800 req/sec with median response times of 110ms. Results may vary depending on application. More testing needs to be conducted. We believe the current upper bound is 5,000 req/sec. Technical Detail : Brev is currently built on top of AWS Lambda where each project is a separate Lambda.","title":"Runtime and Environment"},{"location":"reference/shared-code/","text":"Shared Code You'll notice each project comes with a singular shared code file. The endpoint handlers are defined in your endpoints, but shared logic, such as common functions or classes, can go in shared code. You can access the shared code by importing shared in any endpoint. So the following will return pancakes import shared def get (): return { \"breakfast\" : shared . breakfast } # {\"breakfast\": \"pancakes\"} The next version of Brev will expand this concept, letting you have a more custom file structure.","title":"Shared Code"},{"location":"reference/shared-code/#shared-code","text":"You'll notice each project comes with a singular shared code file. The endpoint handlers are defined in your endpoints, but shared logic, such as common functions or classes, can go in shared code. You can access the shared code by importing shared in any endpoint. So the following will return pancakes import shared def get (): return { \"breakfast\" : shared . breakfast } # {\"breakfast\": \"pancakes\"} The next version of Brev will expand this concept, letting you have a more custom file structure.","title":"Shared Code"},{"location":"tutorials/","text":"Tutorials Tutorial 1: Make a backend for a todo list app. Create tasks, get your tasks, and update them.","title":"Home"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#tutorial-1-make-a-backend-for-a-todo-list-app","text":"Create tasks, get your tasks, and update them.","title":"Tutorial 1: Make a backend for a todo list app."},{"location":"tutorials/to-do-app-backend-tutorial/","text":"Tutorial #1 Make a backend for a todo list app. Create tasks, get your tasks, and update them. This tutorial will walk you through creating 3 APIs on Brev, hooked up to a database to store everything. If you find yourself stuck, wanna brainstorm anything, or just wanna chat, text us: 415-818-0207 The basic design: - GET request to fetch all remaining todos - POST request to create new todos - PUT request to update a todo as completed 1: Create a new project note: you can skip this step if you want to use an existing Brev project Create a folder for this project. Go to that directory in your terminal, and initialize a Brev project. brev init 2: Create the endpoint In the directory of your brev project, create a new endpoint. We named it todos but you can name it however you like. brev endpoint add todos By default, everything with Brev is hosted and deployed for you! Run the below command to see the endpoint URLs. brev list Copy the URL and open it in a new tab with your web browser! You should see an empty response {} Edit the endpoint file with your preferred code editor. You'll see a basic function called get . This is the function that gets called when the URL is hit via an HTTP GET request. 3 Test the instantaneous deploy Change the return of the def get() function, save the file, and refresh the URL in your browser tab. Everything is immediately available! 4 Create new tasks We need to accept tasks to our function. We can send the tasks to our endpoint as JSON. Since Brev is built on top of FastAPI, we can leverage Pydantic BaseModel classes to represent our data. In the same file, above your post function, represent your JSON data as a BaseModel class: from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str Now that we've defined what a todo looks like, we just need to pass it in to our function. We should use a POST request since we're creating new data, so just create a new function called post in our endpoint file. from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post (): return {} Brev will automatically call the post function when the URL is hit with a POST request. Brev endpoint files are the entry points to your project. To create a ToDo, simply pass in an instance of type ToDo . from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo ): return {} Data validation happens automatically! So if your endpoint is called with JSON that doesn't include the status field, it'll return a 403 data validation error. You can comfortably expect your code to only execute if the required parameters are passed in. Test it out! Run your endpoint using an app like Postman, the Brev console, or your terminal! Via the Brev CLI: brev endpoint run todo POST --body '{\"task\":\"Brev Tutorial 1\", \"status\": \"incomplete\"}' 5 Save the tasks in a database Brev comes with a database out of the box. Simply import it to use it! from global_storage import storage_context from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): return {} We're passing an instance of the database to the post function. By giving it the context name \"todos\", Brev will look for the database table named todos , or create it if it doesn't exist -- no initialization needed! :) Now that we have a database set up, let's store the todos, and return a useful message. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } From the Brev dev console, go to the storage viewer to see your database items! 6 Get your active todos Storing is no fun if we can't access everything. Create a GET request that returns your active todos, first passing the database context to your get function. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } 7 The final step is to create an endpoint to modify We want to edit a specific ToDo and mark it as completed. Given a todo ID, we can make a PUT request to change it's state. Add a function for a put request that accepts the ID as a query parameter. (Don't forget to pass the db in as well ) from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): return {} The incoming data to a function can be a variety of types. Using a BaseModel type like we do for the POST request is what specifies incoming data as JSON. Final step is to just pop the associated id from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): db [ id ][ 'status' ] = \"completed\" return { \"result\" : } And there you have it! You now have everything you need to build out a ToDo app! Brev is meant to be configured to your specific use case. Some good next steps for this tutorial: How To: Best Practices for Brev DB Tutorial #2: Make SMS bot w/ Twilio","title":"Tutorial 1"},{"location":"tutorials/to-do-app-backend-tutorial/#tutorial-1","text":"","title":"Tutorial #1"},{"location":"tutorials/to-do-app-backend-tutorial/#make-a-backend-for-a-todo-list-app","text":"Create tasks, get your tasks, and update them. This tutorial will walk you through creating 3 APIs on Brev, hooked up to a database to store everything. If you find yourself stuck, wanna brainstorm anything, or just wanna chat, text us: 415-818-0207 The basic design: - GET request to fetch all remaining todos - POST request to create new todos - PUT request to update a todo as completed","title":"Make a backend for a todo list app."},{"location":"tutorials/to-do-app-backend-tutorial/#1-create-a-new-project","text":"note: you can skip this step if you want to use an existing Brev project Create a folder for this project. Go to that directory in your terminal, and initialize a Brev project. brev init","title":"1: Create a new project"},{"location":"tutorials/to-do-app-backend-tutorial/#2-create-the-endpoint","text":"In the directory of your brev project, create a new endpoint. We named it todos but you can name it however you like. brev endpoint add todos By default, everything with Brev is hosted and deployed for you! Run the below command to see the endpoint URLs. brev list Copy the URL and open it in a new tab with your web browser! You should see an empty response {} Edit the endpoint file with your preferred code editor. You'll see a basic function called get . This is the function that gets called when the URL is hit via an HTTP GET request.","title":"2: Create the endpoint"},{"location":"tutorials/to-do-app-backend-tutorial/#3-test-the-instantaneous-deploy","text":"Change the return of the def get() function, save the file, and refresh the URL in your browser tab. Everything is immediately available!","title":"3 Test the instantaneous deploy"},{"location":"tutorials/to-do-app-backend-tutorial/#4-create-new-tasks","text":"We need to accept tasks to our function. We can send the tasks to our endpoint as JSON. Since Brev is built on top of FastAPI, we can leverage Pydantic BaseModel classes to represent our data. In the same file, above your post function, represent your JSON data as a BaseModel class: from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str Now that we've defined what a todo looks like, we just need to pass it in to our function. We should use a POST request since we're creating new data, so just create a new function called post in our endpoint file. from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post (): return {} Brev will automatically call the post function when the URL is hit with a POST request. Brev endpoint files are the entry points to your project. To create a ToDo, simply pass in an instance of type ToDo . from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo ): return {} Data validation happens automatically! So if your endpoint is called with JSON that doesn't include the status field, it'll return a 403 data validation error. You can comfortably expect your code to only execute if the required parameters are passed in. Test it out! Run your endpoint using an app like Postman, the Brev console, or your terminal! Via the Brev CLI: brev endpoint run todo POST --body '{\"task\":\"Brev Tutorial 1\", \"status\": \"incomplete\"}'","title":"4 Create new tasks"},{"location":"tutorials/to-do-app-backend-tutorial/#5-save-the-tasks-in-a-database","text":"Brev comes with a database out of the box. Simply import it to use it! from global_storage import storage_context from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): return {} We're passing an instance of the database to the post function. By giving it the context name \"todos\", Brev will look for the database table named todos , or create it if it doesn't exist -- no initialization needed! :) Now that we have a database set up, let's store the todos, and return a useful message. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } From the Brev dev console, go to the storage viewer to see your database items!","title":"5 Save the tasks in a database"},{"location":"tutorials/to-do-app-backend-tutorial/#6-get-your-active-todos","text":"Storing is no fun if we can't access everything. Create a GET request that returns your active todos, first passing the database context to your get function. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos }","title":"6 Get your active todos"},{"location":"tutorials/to-do-app-backend-tutorial/#7-the-final-step-is-to-create-an-endpoint-to-modify","text":"We want to edit a specific ToDo and mark it as completed. Given a todo ID, we can make a PUT request to change it's state. Add a function for a put request that accepts the ID as a query parameter. (Don't forget to pass the db in as well ) from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): return {} The incoming data to a function can be a variety of types. Using a BaseModel type like we do for the POST request is what specifies incoming data as JSON. Final step is to just pop the associated id from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): db [ id ][ 'status' ] = \"completed\" return { \"result\" : } And there you have it! You now have everything you need to build out a ToDo app! Brev is meant to be configured to your specific use case.","title":"7 The final step is to create an endpoint to modify"},{"location":"tutorials/to-do-app-backend-tutorial/#some-good-next-steps-for-this-tutorial","text":"How To: Best Practices for Brev DB Tutorial #2: Make SMS bot w/ Twilio","title":"Some good next steps for this tutorial:"}]}